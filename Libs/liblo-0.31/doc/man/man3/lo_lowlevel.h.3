.TH "lo_lowlevel.h" 3 "Thu Apr 16 2020" "Version 0.31" "liblo" \" -*- nroff -*-
.ad l
.nh
.SH NAME
lo_lowlevel.h \- 
.SH SYNOPSIS
.br
.PP
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef long double \fBlo_hires\fP"
.br
.RI "\fIType used to represent numerical values in conversions between OSC types\&. \fP"
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "int \fBlo_send_message\fP (\fBlo_address\fP targ, const char *path, \fBlo_message\fP msg)"
.br
.RI "\fISend a lo_message object to target targ\&. \fP"
.ti -1c
.RI "int \fBlo_send_message_from\fP (\fBlo_address\fP targ, \fBlo_server\fP serv, const char *path, \fBlo_message\fP msg)"
.br
.RI "\fISend a lo_message object to target targ from address of serv\&. \fP"
.ti -1c
.RI "int \fBlo_send_bundle\fP (\fBlo_address\fP targ, \fBlo_bundle\fP b)"
.br
.RI "\fISend a lo_bundle object to address targ\&. \fP"
.ti -1c
.RI "int \fBlo_send_bundle_from\fP (\fBlo_address\fP targ, \fBlo_server\fP serv, \fBlo_bundle\fP b)"
.br
.RI "\fISend a lo_bundle object to address targ from address of serv\&. \fP"
.ti -1c
.RI "\fBlo_message\fP \fBlo_message_new\fP (void)"
.br
.RI "\fICreate a new lo_message object\&. \fP"
.ti -1c
.RI "void \fBlo_message_incref\fP (\fBlo_message\fP m)"
.br
.RI "\fIAdd one to a message's reference count\&. \fP"
.ti -1c
.RI "\fBlo_message\fP \fBlo_message_clone\fP (\fBlo_message\fP m)"
.br
.RI "\fICreate a new lo_message object by cloning an already existing one\&. \fP"
.ti -1c
.RI "void \fBlo_message_free\fP (\fBlo_message\fP m)"
.br
.RI "\fIFree memory allocated by \fBlo_message_new()\fP and any subsequent \fBlo_message_add_int32\fP lo_message_add*() calls\&. \fP"
.ti -1c
.RI "int \fBlo_message_add\fP (\fBlo_message\fP m, const char *types,\&.\&.\&.)"
.br
.RI "\fIAppend a number of arguments to a message\&. \fP"
.ti -1c
.RI "int \fBlo_message_add_varargs\fP (\fBlo_message\fP m, const char *types, va_list ap)"
.br
.RI "\fIAppend a varargs list to a message\&. \fP"
.ti -1c
.RI "int \fBlo_message_add_int32\fP (\fBlo_message\fP m, int32_t a)"
.br
.RI "\fIAppend a data item and typechar of the specified type to a message\&. \fP"
.ti -1c
.RI "int \fBlo_message_add_float\fP (\fBlo_message\fP m, float a)"
.br
.RI "\fIAppend a data item and typechar of the specified type to a message\&. See \fBlo_message_add_int32()\fP for details\&. \fP"
.ti -1c
.RI "int \fBlo_message_add_string\fP (\fBlo_message\fP m, const char *a)"
.br
.RI "\fIAppend a data item and typechar of the specified type to a message\&. See \fBlo_message_add_int32()\fP for details\&. \fP"
.ti -1c
.RI "int \fBlo_message_add_blob\fP (\fBlo_message\fP m, \fBlo_blob\fP a)"
.br
.RI "\fIAppend a data item and typechar of the specified type to a message\&. See \fBlo_message_add_int32()\fP for details\&. \fP"
.ti -1c
.RI "int \fBlo_message_add_int64\fP (\fBlo_message\fP m, int64_t a)"
.br
.RI "\fIAppend a data item and typechar of the specified type to a message\&. See \fBlo_message_add_int32()\fP for details\&. \fP"
.ti -1c
.RI "int \fBlo_message_add_timetag\fP (\fBlo_message\fP m, \fBlo_timetag\fP a)"
.br
.RI "\fIAppend a data item and typechar of the specified type to a message\&. See \fBlo_message_add_int32()\fP for details\&. \fP"
.ti -1c
.RI "int \fBlo_message_add_double\fP (\fBlo_message\fP m, double a)"
.br
.RI "\fIAppend a data item and typechar of the specified type to a message\&. See \fBlo_message_add_int32()\fP for details\&. \fP"
.ti -1c
.RI "int \fBlo_message_add_symbol\fP (\fBlo_message\fP m, const char *a)"
.br
.RI "\fIAppend a data item and typechar of the specified type to a message\&. See \fBlo_message_add_int32()\fP for details\&. \fP"
.ti -1c
.RI "int \fBlo_message_add_char\fP (\fBlo_message\fP m, char a)"
.br
.RI "\fIAppend a data item and typechar of the specified type to a message\&. See \fBlo_message_add_int32()\fP for details\&. \fP"
.ti -1c
.RI "int \fBlo_message_add_midi\fP (\fBlo_message\fP m, uint8_t a[4])"
.br
.RI "\fIAppend a data item and typechar of the specified type to a message\&. See \fBlo_message_add_int32()\fP for details\&. \fP"
.ti -1c
.RI "int \fBlo_message_add_true\fP (\fBlo_message\fP m)"
.br
.RI "\fIAppend a data item and typechar of the specified type to a message\&. See \fBlo_message_add_int32()\fP for details\&. \fP"
.ti -1c
.RI "int \fBlo_message_add_false\fP (\fBlo_message\fP m)"
.br
.RI "\fIAppend a data item and typechar of the specified type to a message\&. See \fBlo_message_add_int32()\fP for details\&. \fP"
.ti -1c
.RI "int \fBlo_message_add_nil\fP (\fBlo_message\fP m)"
.br
.RI "\fIAppend a data item and typechar of the specified type to a message\&. See \fBlo_message_add_int32()\fP for details\&. \fP"
.ti -1c
.RI "int \fBlo_message_add_infinitum\fP (\fBlo_message\fP m)"
.br
.RI "\fIAppend a data item and typechar of the specified type to a message\&. See \fBlo_message_add_int32()\fP for details\&. \fP"
.ti -1c
.RI "\fBlo_address\fP \fBlo_message_get_source\fP (\fBlo_message\fP m)"
.br
.RI "\fIReturns the source (lo_address) of an incoming message\&. \fP"
.ti -1c
.RI "\fBlo_timetag\fP \fBlo_message_get_timestamp\fP (\fBlo_message\fP m)"
.br
.RI "\fIReturns the timestamp (\fBlo_timetag\fP *) of a bundled incoming message\&. \fP"
.ti -1c
.RI "char * \fBlo_message_get_types\fP (\fBlo_message\fP m)"
.br
.RI "\fIReturn the message type tag string\&. \fP"
.ti -1c
.RI "int \fBlo_message_get_argc\fP (\fBlo_message\fP m)"
.br
.RI "\fIReturn the message argument count\&. \fP"
.ti -1c
.RI "\fBlo_arg\fP ** \fBlo_message_get_argv\fP (\fBlo_message\fP m)"
.br
.RI "\fIReturn the message arguments\&. Do not free the returned data\&. \fP"
.ti -1c
.RI "size_t \fBlo_message_length\fP (\fBlo_message\fP m, const char *path)"
.br
.RI "\fIReturn the length of a message in bytes\&. \fP"
.ti -1c
.RI "void * \fBlo_message_serialise\fP (\fBlo_message\fP m, const char *path, void *to, size_t *size)"
.br
.RI "\fISerialise the lo_message object to an area of memory and return a pointer to the serialised form\&. Opposite of \fBlo_message_deserialise()\fP\&. \fP"
.ti -1c
.RI "\fBlo_message\fP \fBlo_message_deserialise\fP (void *data, size_t size, int *result)"
.br
.RI "\fIDeserialise a raw OSC message and return a new lo_message object\&. Opposite of \fBlo_message_serialise()\fP\&. \fP"
.ti -1c
.RI "int \fBlo_server_dispatch_data\fP (\fBlo_server\fP s, void *data, size_t size)"
.br
.RI "\fIDispatch a raw block of memory containing an OSC message\&. \fP"
.ti -1c
.RI "const char * \fBlo_address_get_hostname\fP (\fBlo_address\fP a)"
.br
.RI "\fIReturn the hostname of a lo_address object\&. \fP"
.ti -1c
.RI "const char * \fBlo_address_get_port\fP (\fBlo_address\fP a)"
.br
.RI "\fIReturn the port/service name of a lo_address object\&. \fP"
.ti -1c
.RI "int \fBlo_address_get_protocol\fP (\fBlo_address\fP a)"
.br
.RI "\fIReturn the protocol of a lo_address object\&. \fP"
.ti -1c
.RI "char * \fBlo_address_get_url\fP (\fBlo_address\fP a)"
.br
.RI "\fIReturn a URL representing an OSC address\&. \fP"
.ti -1c
.RI "void \fBlo_address_set_ttl\fP (\fBlo_address\fP t, int ttl)"
.br
.RI "\fISet the Time-to-Live value for a given target address\&. \fP"
.ti -1c
.RI "int \fBlo_address_get_ttl\fP (\fBlo_address\fP t)"
.br
.RI "\fIGet the Time-to-Live value for a given target address\&. \fP"
.ti -1c
.RI "int \fBlo_address_set_iface\fP (\fBlo_address\fP t, const char *iface, const char *ip)"
.br
.RI "\fISet the network interface to use for a given target address\&. \fP"
.ti -1c
.RI "const char * \fBlo_address_get_iface\fP (\fBlo_address\fP t)"
.br
.RI "\fIGet the name of the network interface assigned to an OSC address\&. \fP"
.ti -1c
.RI "int \fBlo_address_set_tcp_nodelay\fP (\fBlo_address\fP t, int enable)"
.br
.RI "\fISet the TCP_NODELAY flag on outgoing TCP connections\&. \fP"
.ti -1c
.RI "int \fBlo_address_set_stream_slip\fP (\fBlo_address\fP t, int enable)"
.br
.RI "\fISet outgoing stream connections (e\&.g\&., TCP) to be transmitted using the SLIP packetizing protocol\&. \fP"
.ti -1c
.RI "\fBlo_bundle\fP \fBlo_bundle_new\fP (\fBlo_timetag\fP tt)"
.br
.RI "\fICreate a new bundle object\&. \fP"
.ti -1c
.RI "void \fBlo_bundle_incref\fP (\fBlo_bundle\fP b)"
.br
.RI "\fIAdd one to a bundle's reference count\&. \fP"
.ti -1c
.RI "int \fBlo_bundle_add_message\fP (\fBlo_bundle\fP b, const char *path, \fBlo_message\fP m)"
.br
.RI "\fIAdds an OSC message to an existing bundle\&. \fP"
.ti -1c
.RI "int \fBlo_bundle_add_bundle\fP (\fBlo_bundle\fP b, \fBlo_bundle\fP n)"
.br
.RI "\fIAdds an OSC bundle to an existing bundle\&. \fP"
.ti -1c
.RI "size_t \fBlo_bundle_length\fP (\fBlo_bundle\fP b)"
.br
.RI "\fIReturn the length of a bundle in bytes\&. \fP"
.ti -1c
.RI "unsigned int \fBlo_bundle_count\fP (\fBlo_bundle\fP b)"
.br
.RI "\fIReturn the number of top-level elements in a bundle\&. \fP"
.ti -1c
.RI "\fBlo_element_type\fP \fBlo_bundle_get_type\fP (\fBlo_bundle\fP b, int index)"
.br
.RI "\fIGets the element type contained within a bundle\&. \fP"
.ti -1c
.RI "\fBlo_bundle\fP \fBlo_bundle_get_bundle\fP (\fBlo_bundle\fP b, int index)"
.br
.RI "\fIGets a nested bundle contained within a bundle\&. \fP"
.ti -1c
.RI "\fBlo_message\fP \fBlo_bundle_get_message\fP (\fBlo_bundle\fP b, int index, const char **path)"
.br
.RI "\fIGets a message contained within a bundle\&. \fP"
.ti -1c
.RI "\fBlo_timetag\fP \fBlo_bundle_get_timestamp\fP (\fBlo_bundle\fP b)"
.br
.RI "\fIGet the timestamp associated with a bundle\&. \fP"
.ti -1c
.RI "void * \fBlo_bundle_serialise\fP (\fBlo_bundle\fP b, void *to, size_t *size)"
.br
.RI "\fISerialise the bundle object to an area of memory and return a pointer to the serialised form\&. \fP"
.ti -1c
.RI "void \fBlo_bundle_free\fP (\fBlo_bundle\fP b)"
.br
.RI "\fIFrees the memory taken by a bundle object\&. \fP"
.ti -1c
.RI "void \fBlo_bundle_free_recursive\fP (\fBlo_bundle\fP b)"
.br
.RI "\fIFrees the memory taken by a bundle object and its messages and nested bundles recursively\&. \fP"
.ti -1c
.RI "void \fBlo_bundle_free_messages\fP (\fBlo_bundle\fP b)"
.br
.RI "\fIObsolete, use lo_bundle_free_recursive instead\&. \fP"
.ti -1c
.RI "int \fBlo_is_numerical_type\fP (\fBlo_type\fP a)"
.br
.RI "\fIReturn true if the type specified has a numerical value, such as LO_INT32, LO_FLOAT etc\&. \fP"
.ti -1c
.RI "int \fBlo_is_string_type\fP (\fBlo_type\fP a)"
.br
.RI "\fIReturn true if the type specified has a textual value, such as LO_STRING or LO_SYMBOL\&. \fP"
.ti -1c
.RI "int \fBlo_coerce\fP (\fBlo_type\fP type_to, \fBlo_arg\fP *to, \fBlo_type\fP type_from, \fBlo_arg\fP *from)"
.br
.RI "\fIAttempt to convert one OSC type to another\&. \fP"
.ti -1c
.RI "\fBlo_hires\fP \fBlo_hires_val\fP (\fBlo_type\fP type, \fBlo_arg\fP *p)"
.br
.RI "\fIReturn the numerical value of the given argument with the maximum native system precision\&. \fP"
.ti -1c
.RI "\fBlo_server\fP \fBlo_server_new\fP (const char *port, \fBlo_err_handler\fP err_h)"
.br
.RI "\fICreate a new server instance\&. \fP"
.ti -1c
.RI "\fBlo_server\fP \fBlo_server_new_with_proto\fP (const char *port, int proto, \fBlo_err_handler\fP err_h)"
.br
.RI "\fICreate a new server instance, specifying protocol\&. \fP"
.ti -1c
.RI "\fBlo_server\fP \fBlo_server_new_multicast\fP (const char *group, const char *port, \fBlo_err_handler\fP err_h)"
.br
.RI "\fICreate a new server instance, and join a UDP multicast group\&. \fP"
.ti -1c
.RI "\fBlo_server\fP \fBlo_server_new_multicast_iface\fP (const char *group, const char *port, const char *iface, const char *ip, \fBlo_err_handler\fP err_h)"
.br
.RI "\fICreate a new server instance, and join a UDP multicast group, optionally specifying which network interface to use\&. Note that usually only one of iface or ip are specified\&. \fP"
.ti -1c
.RI "\fBlo_server\fP \fBlo_server_new_from_url\fP (const char *url, \fBlo_err_handler\fP err_h)"
.br
.RI "\fICreate a new server instance, taking port and the optional multicast group IP from an URL string\&. \fP"
.ti -1c
.RI "int \fBlo_server_enable_coercion\fP (\fBlo_server\fP server, int enable)"
.br
.RI "\fIEnables or disables type coercion during message dispatch\&. \fP"
.ti -1c
.RI "void \fBlo_server_free\fP (\fBlo_server\fP s)"
.br
.RI "\fIFree up memory used by the lo_server object\&. \fP"
.ti -1c
.RI "int \fBlo_server_wait\fP (\fBlo_server\fP s, int timeout)"
.br
.RI "\fIWait for an OSC message to be received\&. \fP"
.ti -1c
.RI "int \fBlo_servers_wait\fP (\fBlo_server\fP *s, int *status, int num_servers, int timeout)"
.br
.RI "\fIWait on multiple servers for an OSC message to be received\&. \fP"
.ti -1c
.RI "int \fBlo_server_recv_noblock\fP (\fBlo_server\fP s, int timeout)"
.br
.RI "\fILook for an OSC message waiting to be received\&. \fP"
.ti -1c
.RI "int \fBlo_servers_recv_noblock\fP (\fBlo_server\fP *s, int *recvd, int num_servers, int timeout)"
.br
.RI "\fILook for an OSC message waiting to be received on multiple servers\&. \fP"
.ti -1c
.RI "int \fBlo_server_recv\fP (\fBlo_server\fP s)"
.br
.RI "\fIBlock, waiting for an OSC message to be received\&. \fP"
.ti -1c
.RI "\fBlo_method\fP \fBlo_server_add_method\fP (\fBlo_server\fP s, const char *path, const char *typespec, \fBlo_method_handler\fP h, const void *user_data)"
.br
.RI "\fIAdd an OSC method to the specifed server\&. \fP"
.ti -1c
.RI "void \fBlo_server_del_method\fP (\fBlo_server\fP s, const char *path, const char *typespec)"
.br
.RI "\fIDelete an OSC method from the specified server\&. \fP"
.ti -1c
.RI "int \fBlo_server_del_lo_method\fP (\fBlo_server\fP s, \fBlo_method\fP m)"
.br
.RI "\fIDelete a specific OSC method from the specified server\&. \fP"
.ti -1c
.RI "int \fBlo_server_add_bundle_handlers\fP (\fBlo_server\fP s, \fBlo_bundle_start_handler\fP sh, \fBlo_bundle_end_handler\fP eh, void *user_data)"
.br
.RI "\fIAdd bundle notification handlers to the specified server\&. \fP"
.ti -1c
.RI "int \fBlo_server_get_socket_fd\fP (\fBlo_server\fP s)"
.br
.RI "\fIReturn the file descriptor of the server socket\&. \fP"
.ti -1c
.RI "int \fBlo_server_get_port\fP (\fBlo_server\fP s)"
.br
.RI "\fIReturn the port number that the server has bound to\&. \fP"
.ti -1c
.RI "int \fBlo_server_get_protocol\fP (\fBlo_server\fP s)"
.br
.RI "\fIReturn the protocol that the server is using\&. \fP"
.ti -1c
.RI "char * \fBlo_server_get_url\fP (\fBlo_server\fP s)"
.br
.RI "\fIReturn an OSC URL that can be used to contact the server\&. \fP"
.ti -1c
.RI "int \fBlo_server_enable_queue\fP (\fBlo_server\fP s, int queue_enabled, int dispatch_remaining)"
.br
.RI "\fIToggle event queue\&. If queueing is enabled, timetagged messages that are sent in advance of the current time will be put on an internal queue, and they will be dispatched at the indicated time\&. By default, queueing is enabled\&. Use this function to disable it, if it is desired to have a server process messages immediately\&. In that case, use \fBlo_message_get_timestamp()\fP to get the message timestamp from within a method handler\&. \fP"
.ti -1c
.RI "int \fBlo_server_events_pending\fP (\fBlo_server\fP s)"
.br
.RI "\fIReturn true if there are scheduled events (eg\&. from bundles) waiting to be dispatched by the server\&. \fP"
.ti -1c
.RI "double \fBlo_server_next_event_delay\fP (\fBlo_server\fP s)"
.br
.RI "\fIReturn the time in seconds until the next scheduled event\&. \fP"
.ti -1c
.RI "int \fBlo_server_max_msg_size\fP (\fBlo_server\fP s, int req_size)"
.br
.RI "\fISet the maximum message size accepted by a server\&. \fP"
.ti -1c
.RI "char * \fBlo_url_get_protocol\fP (const char *url)"
.br
.RI "\fIReturn the protocol portion of an OSC URL, eg\&. udp, tcp\&. \fP"
.ti -1c
.RI "int \fBlo_url_get_protocol_id\fP (const char *url)"
.br
.RI "\fIReturn the protocol ID of an OSC URL\&. \fP"
.ti -1c
.RI "char * \fBlo_url_get_hostname\fP (const char *url)"
.br
.RI "\fIReturn the hostname portion of an OSC URL\&. \fP"
.ti -1c
.RI "char * \fBlo_url_get_port\fP (const char *url)"
.br
.RI "\fIReturn the port portion of an OSC URL\&. \fP"
.ti -1c
.RI "char * \fBlo_url_get_path\fP (const char *url)"
.br
.RI "\fIReturn the path portion of an OSC URL\&. \fP"
.ti -1c
.RI "int \fBlo_strsize\fP (const char *s)"
.br
.RI "\fIA function to calculate the amount of OSC message space required by a C char *\&. \fP"
.ti -1c
.RI "uint32_t \fBlo_blobsize\fP (\fBlo_blob\fP b)"
.br
.RI "\fIA function to calculate the amount of OSC message space required by a lo_blob object\&. \fP"
.ti -1c
.RI "int \fBlo_pattern_match\fP (const char *str, const char *p)"
.br
.RI "\fITest a string against an OSC pattern glob\&. \fP"
.ti -1c
.RI "double \fBlo_timetag_diff\fP (\fBlo_timetag\fP a, \fBlo_timetag\fP b)"
.br
.RI "\fIFind the time difference between two timetags\&. \fP"
.ti -1c
.RI "void \fBlo_timetag_now\fP (\fBlo_timetag\fP *t)"
.br
.RI "\fIReturn a timetag for the current time\&. \fP"
.ti -1c
.RI "size_t \fBlo_arg_size\fP (\fBlo_type\fP type, void *data)"
.br
.RI "\fIReturn the storage size, in bytes, of the given argument\&. \fP"
.ti -1c
.RI "char * \fBlo_get_path\fP (void *data, ssize_t size)"
.br
.RI "\fIGiven a raw OSC message, return the message path\&. \fP"
.ti -1c
.RI "void \fBlo_arg_host_endian\fP (\fBlo_type\fP type, void *data)"
.br
.RI "\fIConvert the specified argument to host byte order where necessary\&. \fP"
.ti -1c
.RI "void \fBlo_arg_network_endian\fP (\fBlo_type\fP type, void *data)"
.br
.RI "\fIConvert the specified argument to network byte order where necessary\&. \fP"
.ti -1c
.RI "void \fBlo_bundle_pp\fP (\fBlo_bundle\fP b)"
.br
.RI "\fIPretty-print a lo_bundle object\&. \fP"
.ti -1c
.RI "void \fBlo_message_pp\fP (\fBlo_message\fP m)"
.br
.RI "\fIPretty-print a lo_message object\&. \fP"
.ti -1c
.RI "void \fBlo_arg_pp\fP (\fBlo_type\fP type, void *data)"
.br
.RI "\fIPretty-print a set of typed arguments\&. \fP"
.ti -1c
.RI "void \fBlo_server_pp\fP (\fBlo_server\fP s)"
.br
.RI "\fIPretty-print a lo_server object\&. \fP"
.ti -1c
.RI "void \fBlo_method_pp\fP (\fBlo_method\fP m)"
.br
.RI "\fIPretty-print a lo_method object\&. \fP"
.ti -1c
.RI "void \fBlo_method_pp_prefix\fP (\fBlo_method\fP m, const char *p)"
.br
.RI "\fIPretty-print a lo_method object, but prepend a given prefix to all field names\&. \fP"
.in -1c
.SH "Detailed Description"
.PP 
The liblo headerfile defining the low-level API functions\&. 
.PP
Definition in file \fBlo_lowlevel\&.h\fP\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for liblo from the source code\&.
