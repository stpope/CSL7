<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>liblo: lo_serverthread.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">liblo
   &#160;<span id="projectnumber">0.31</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_a367011633491839d8249188e87c7833.html">lo</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">lo_serverthread.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a href="lo__serverthread_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:abe3e0c31189adfd7624de6c507b610ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="lo__types_8h.html#a09996ffb6bde21b8fb6106897b88feae">lo_server_thread</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lo__serverthread_8h.html#abe3e0c31189adfd7624de6c507b610ba">lo_server_thread_new</a> (const char *port, <a class="el" href="lo__types_8h.html#aa5d2e4aa0ff9d4459fcc76e7ed5839fc">lo_err_handler</a> err_h)</td></tr>
<tr class="memdesc:abe3e0c31189adfd7624de6c507b610ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new server thread to handle incoming OSC messages.  <a href="#abe3e0c31189adfd7624de6c507b610ba">More...</a><br /></td></tr>
<tr class="separator:abe3e0c31189adfd7624de6c507b610ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fa9fcae4eabe09847d46b134dc33aa4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="lo__types_8h.html#a09996ffb6bde21b8fb6106897b88feae">lo_server_thread</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lo__serverthread_8h.html#a0fa9fcae4eabe09847d46b134dc33aa4">lo_server_thread_new_multicast</a> (const char *group, const char *port, <a class="el" href="lo__types_8h.html#aa5d2e4aa0ff9d4459fcc76e7ed5839fc">lo_err_handler</a> err_h)</td></tr>
<tr class="memdesc:a0fa9fcae4eabe09847d46b134dc33aa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new server thread to handle incoming OSC messages, and join a UDP multicast group.  <a href="#a0fa9fcae4eabe09847d46b134dc33aa4">More...</a><br /></td></tr>
<tr class="separator:a0fa9fcae4eabe09847d46b134dc33aa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6d57101bbdaa6571ed76373b2c3a50a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="lo__types_8h.html#a09996ffb6bde21b8fb6106897b88feae">lo_server_thread</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lo__serverthread_8h.html#ad6d57101bbdaa6571ed76373b2c3a50a">lo_server_thread_new_multicast_iface</a> (const char *group, const char *port, const char *iface, const char *ip, <a class="el" href="lo__types_8h.html#aa5d2e4aa0ff9d4459fcc76e7ed5839fc">lo_err_handler</a> err_h)</td></tr>
<tr class="memdesc:ad6d57101bbdaa6571ed76373b2c3a50a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new server thread instance, and join a UDP multicast group, optionally specifying which network interface to use. Note that usually only one of iface or ip are specified.  <a href="#ad6d57101bbdaa6571ed76373b2c3a50a">More...</a><br /></td></tr>
<tr class="separator:ad6d57101bbdaa6571ed76373b2c3a50a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6713cedfb0b2c4f066ec8a19366bf095"><td class="memItemLeft" align="right" valign="top"><a class="el" href="lo__types_8h.html#a09996ffb6bde21b8fb6106897b88feae">lo_server_thread</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lo__serverthread_8h.html#a6713cedfb0b2c4f066ec8a19366bf095">lo_server_thread_new_with_proto</a> (const char *port, int proto, <a class="el" href="lo__types_8h.html#aa5d2e4aa0ff9d4459fcc76e7ed5839fc">lo_err_handler</a> err_h)</td></tr>
<tr class="memdesc:a6713cedfb0b2c4f066ec8a19366bf095"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new server thread to handle incoming OSC messages, specifying protocol.  <a href="#a6713cedfb0b2c4f066ec8a19366bf095">More...</a><br /></td></tr>
<tr class="separator:a6713cedfb0b2c4f066ec8a19366bf095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac49abadaaac33408eae4060bb44b9a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="lo__types_8h.html#a09996ffb6bde21b8fb6106897b88feae">lo_server_thread</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lo__serverthread_8h.html#aac49abadaaac33408eae4060bb44b9a2">lo_server_thread_new_from_url</a> (const char *url, <a class="el" href="lo__types_8h.html#aa5d2e4aa0ff9d4459fcc76e7ed5839fc">lo_err_handler</a> err_h)</td></tr>
<tr class="memdesc:aac49abadaaac33408eae4060bb44b9a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new server thread, taking port and the optional multicast group IP from an URL string.  <a href="#aac49abadaaac33408eae4060bb44b9a2">More...</a><br /></td></tr>
<tr class="separator:aac49abadaaac33408eae4060bb44b9a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad72be3f2a81b9583ad69dd007080c0e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lo__serverthread_8h.html#ad72be3f2a81b9583ad69dd007080c0e5">lo_server_thread_free</a> (<a class="el" href="lo__types_8h.html#a09996ffb6bde21b8fb6106897b88feae">lo_server_thread</a> st)</td></tr>
<tr class="memdesc:ad72be3f2a81b9583ad69dd007080c0e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free memory taken by a server thread.  <a href="#ad72be3f2a81b9583ad69dd007080c0e5">More...</a><br /></td></tr>
<tr class="separator:ad72be3f2a81b9583ad69dd007080c0e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af500729c76fd5bb4798d350b6307adc1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="lo__types_8h.html#a66faedf5da13231d8c0166870477dce5">lo_method</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lo__serverthread_8h.html#af500729c76fd5bb4798d350b6307adc1">lo_server_thread_add_method</a> (<a class="el" href="lo__types_8h.html#a09996ffb6bde21b8fb6106897b88feae">lo_server_thread</a> st, const char *path, const char *typespec, <a class="el" href="lo__types_8h.html#a3b1c86c0925d05e13b5438ce8fe80a6c">lo_method_handler</a> h, const void *user_data)</td></tr>
<tr class="memdesc:af500729c76fd5bb4798d350b6307adc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an OSC method to the specifed server thread.  <a href="#af500729c76fd5bb4798d350b6307adc1">More...</a><br /></td></tr>
<tr class="separator:af500729c76fd5bb4798d350b6307adc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a072edf53338bc807444c4b510643a828"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lo__serverthread_8h.html#a072edf53338bc807444c4b510643a828">lo_server_thread_del_method</a> (<a class="el" href="lo__types_8h.html#a09996ffb6bde21b8fb6106897b88feae">lo_server_thread</a> st, const char *path, const char *typespec)</td></tr>
<tr class="memdesc:a072edf53338bc807444c4b510643a828"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete an OSC method from the specifed server thread.  <a href="#a072edf53338bc807444c4b510643a828">More...</a><br /></td></tr>
<tr class="separator:a072edf53338bc807444c4b510643a828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28733dd7fc8e8df6969674779d74fddd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lo__serverthread_8h.html#a28733dd7fc8e8df6969674779d74fddd">lo_server_thread_del_lo_method</a> (<a class="el" href="lo__types_8h.html#a09996ffb6bde21b8fb6106897b88feae">lo_server_thread</a> st, <a class="el" href="lo__types_8h.html#a66faedf5da13231d8c0166870477dce5">lo_method</a> m)</td></tr>
<tr class="memdesc:a28733dd7fc8e8df6969674779d74fddd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete an OSC method from the specified server thread.  <a href="#a28733dd7fc8e8df6969674779d74fddd">More...</a><br /></td></tr>
<tr class="separator:a28733dd7fc8e8df6969674779d74fddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4d5248ecc0d55e46c0f025e727ceb52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lo__serverthread_8h.html#ab4d5248ecc0d55e46c0f025e727ceb52">lo_server_thread_set_callbacks</a> (<a class="el" href="lo__types_8h.html#a09996ffb6bde21b8fb6106897b88feae">lo_server_thread</a> st, <a class="el" href="lo__types_8h.html#a7686daba989edab6324cb2957f9f1333">lo_server_thread_init_callback</a> init, <a class="el" href="lo__types_8h.html#a79a141110b391d4a8c62a3cd397de175">lo_server_thread_cleanup_callback</a> cleanup, void *user_data)</td></tr>
<tr class="memdesc:ab4d5248ecc0d55e46c0f025e727ceb52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an init and/or a cleanup function to the specifed server thread.  <a href="#ab4d5248ecc0d55e46c0f025e727ceb52">More...</a><br /></td></tr>
<tr class="separator:ab4d5248ecc0d55e46c0f025e727ceb52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b284c1b96d0354c5de4ff7ba5a44fbc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lo__serverthread_8h.html#a4b284c1b96d0354c5de4ff7ba5a44fbc">lo_server_thread_start</a> (<a class="el" href="lo__types_8h.html#a09996ffb6bde21b8fb6106897b88feae">lo_server_thread</a> st)</td></tr>
<tr class="memdesc:a4b284c1b96d0354c5de4ff7ba5a44fbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the server thread.  <a href="#a4b284c1b96d0354c5de4ff7ba5a44fbc">More...</a><br /></td></tr>
<tr class="separator:a4b284c1b96d0354c5de4ff7ba5a44fbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06992ac46b04e58cb77d7c519a578f57"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lo__serverthread_8h.html#a06992ac46b04e58cb77d7c519a578f57">lo_server_thread_stop</a> (<a class="el" href="lo__types_8h.html#a09996ffb6bde21b8fb6106897b88feae">lo_server_thread</a> st)</td></tr>
<tr class="memdesc:a06992ac46b04e58cb77d7c519a578f57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop the server thread.  <a href="#a06992ac46b04e58cb77d7c519a578f57">More...</a><br /></td></tr>
<tr class="separator:a06992ac46b04e58cb77d7c519a578f57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22f4b18eeac41490647ab9fe2333f933"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lo__serverthread_8h.html#a22f4b18eeac41490647ab9fe2333f933">lo_server_thread_get_port</a> (<a class="el" href="lo__types_8h.html#a09996ffb6bde21b8fb6106897b88feae">lo_server_thread</a> st)</td></tr>
<tr class="memdesc:a22f4b18eeac41490647ab9fe2333f933"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the port number that the server thread has bound to.  <a href="#a22f4b18eeac41490647ab9fe2333f933">More...</a><br /></td></tr>
<tr class="separator:a22f4b18eeac41490647ab9fe2333f933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2805a7cbdd9465be4ca5101c569faf0"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lo__serverthread_8h.html#ac2805a7cbdd9465be4ca5101c569faf0">lo_server_thread_get_url</a> (<a class="el" href="lo__types_8h.html#a09996ffb6bde21b8fb6106897b88feae">lo_server_thread</a> st)</td></tr>
<tr class="memdesc:ac2805a7cbdd9465be4ca5101c569faf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a URL describing the address of the server thread.  <a href="#ac2805a7cbdd9465be4ca5101c569faf0">More...</a><br /></td></tr>
<tr class="separator:ac2805a7cbdd9465be4ca5101c569faf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab968d51fa6e0d4bea92e3f84f5556161"><td class="memItemLeft" align="right" valign="top"><a class="el" href="lo__types_8h.html#a59067bf50cf8abb4371da6f03c9036c9">lo_server</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lo__serverthread_8h.html#ab968d51fa6e0d4bea92e3f84f5556161">lo_server_thread_get_server</a> (<a class="el" href="lo__types_8h.html#a09996ffb6bde21b8fb6106897b88feae">lo_server_thread</a> st)</td></tr>
<tr class="memdesc:ab968d51fa6e0d4bea92e3f84f5556161"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the lo_server for a lo_server_thread.  <a href="#ab968d51fa6e0d4bea92e3f84f5556161">More...</a><br /></td></tr>
<tr class="separator:ab968d51fa6e0d4bea92e3f84f5556161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bc3d8361b65e3ad112a1da956d9114e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lo__serverthread_8h.html#a7bc3d8361b65e3ad112a1da956d9114e">lo_server_thread_events_pending</a> (<a class="el" href="lo__types_8h.html#a09996ffb6bde21b8fb6106897b88feae">lo_server_thread</a> st)</td></tr>
<tr class="memdesc:a7bc3d8361b65e3ad112a1da956d9114e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if there are scheduled events (eg. from bundles) waiting to be dispatched by the thread.  <a href="#a7bc3d8361b65e3ad112a1da956d9114e">More...</a><br /></td></tr>
<tr class="separator:a7bc3d8361b65e3ad112a1da956d9114e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ba794aacbb04dada6939980ce71381a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lo__serverthread_8h.html#a6ba794aacbb04dada6939980ce71381a">lo_server_thread_pp</a> (<a class="el" href="lo__types_8h.html#a09996ffb6bde21b8fb6106897b88feae">lo_server_thread</a> st)</td></tr>
<tr class="memdesc:a6ba794aacbb04dada6939980ce71381a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pretty-print a lo_server_thread object.  <a href="#a6ba794aacbb04dada6939980ce71381a">More...</a><br /></td></tr>
<tr class="separator:a6ba794aacbb04dada6939980ce71381a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The liblo headerfile declaring thread-related functions. </p>

<p>Definition in file <a class="el" href="lo__serverthread_8h_source.html">lo_serverthread.h</a>.</p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="af500729c76fd5bb4798d350b6307adc1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="lo__types_8h.html#a66faedf5da13231d8c0166870477dce5">lo_method</a> lo_server_thread_add_method </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lo__types_8h.html#a09996ffb6bde21b8fb6106897b88feae">lo_server_thread</a>&#160;</td>
          <td class="paramname"><em>st</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>typespec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lo__types_8h.html#a3b1c86c0925d05e13b5438ce8fe80a6c">lo_method_handler</a>&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>user_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add an OSC method to the specifed server thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">st</td><td>The server thread the method is to be added to. </td></tr>
    <tr><td class="paramname">path</td><td>The OSC path to register the method to. If NULL is passed the method will match all paths. </td></tr>
    <tr><td class="paramname">typespec</td><td>The typespec the method accepts. Incoming messages with similar typespecs (e.g. ones with numerical types in the same position) will be coerced to the typespec given here. </td></tr>
    <tr><td class="paramname">h</td><td>The method handler callback function that will be called it a matching message is received </td></tr>
    <tr><td class="paramname">user_data</td><td>A value that will be passed to the callback function, h, when its invoked matching from this method. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a28733dd7fc8e8df6969674779d74fddd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lo_server_thread_del_lo_method </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lo__types_8h.html#a09996ffb6bde21b8fb6106897b88feae">lo_server_thread</a>&#160;</td>
          <td class="paramname"><em>st</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lo__types_8h.html#a66faedf5da13231d8c0166870477dce5">lo_method</a>&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete an OSC method from the specified server thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The server thread the method is to be removed from. </td></tr>
    <tr><td class="paramname">m</td><td>The lo_method identifier returned from lo_server_add_method for the method to delete from the server. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero if it was not found in the list of methods for the server. </dd></dl>

</div>
</div>
<a class="anchor" id="a072edf53338bc807444c4b510643a828"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lo_server_thread_del_method </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lo__types_8h.html#a09996ffb6bde21b8fb6106897b88feae">lo_server_thread</a>&#160;</td>
          <td class="paramname"><em>st</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>typespec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete an OSC method from the specifed server thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">st</td><td>The server thread the method is to be removed from. </td></tr>
    <tr><td class="paramname">path</td><td>The OSC path of the method to delete. If NULL is passed the method will match the generic handler. </td></tr>
    <tr><td class="paramname">typespec</td><td>The typespec the method accepts. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7bc3d8361b65e3ad112a1da956d9114e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lo_server_thread_events_pending </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lo__types_8h.html#a09996ffb6bde21b8fb6106897b88feae">lo_server_thread</a>&#160;</td>
          <td class="paramname"><em>st</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if there are scheduled events (eg. from bundles) waiting to be dispatched by the thread. </p>

</div>
</div>
<a class="anchor" id="ad72be3f2a81b9583ad69dd007080c0e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lo_server_thread_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lo__types_8h.html#a09996ffb6bde21b8fb6106897b88feae">lo_server_thread</a>&#160;</td>
          <td class="paramname"><em>st</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free memory taken by a server thread. </p>
<p>Frees the memory, and, if currently running will stop the associated thread. </p>

</div>
</div>
<a class="anchor" id="a22f4b18eeac41490647ab9fe2333f933"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lo_server_thread_get_port </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lo__types_8h.html#a09996ffb6bde21b8fb6106897b88feae">lo_server_thread</a>&#160;</td>
          <td class="paramname"><em>st</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the port number that the server thread has bound to. </p>

</div>
</div>
<a class="anchor" id="ab968d51fa6e0d4bea92e3f84f5556161"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="lo__types_8h.html#a59067bf50cf8abb4371da6f03c9036c9">lo_server</a> lo_server_thread_get_server </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lo__types_8h.html#a09996ffb6bde21b8fb6106897b88feae">lo_server_thread</a>&#160;</td>
          <td class="paramname"><em>st</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the lo_server for a lo_server_thread. </p>
<p>This function is useful for passing a thread's lo_server to <a class="el" href="group__liblo.html#gaa4a314562b09e2fd00749a5d0b4d0955" title="Send a OSC formatted message to the address specified, from the same socket as the specified server...">lo_send_from()</a>. </p>

</div>
</div>
<a class="anchor" id="ac2805a7cbdd9465be4ca5101c569faf0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* lo_server_thread_get_url </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lo__types_8h.html#a09996ffb6bde21b8fb6106897b88feae">lo_server_thread</a>&#160;</td>
          <td class="paramname"><em>st</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a URL describing the address of the server thread. </p>
<p>Return value must be free()'d to reclaim memory. </p>

</div>
</div>
<a class="anchor" id="abe3e0c31189adfd7624de6c507b610ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="lo__types_8h.html#a09996ffb6bde21b8fb6106897b88feae">lo_server_thread</a> lo_server_thread_new </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lo__types_8h.html#aa5d2e4aa0ff9d4459fcc76e7ed5839fc">lo_err_handler</a>&#160;</td>
          <td class="paramname"><em>err_h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new server thread to handle incoming OSC messages. </p>
<p>Server threads take care of the message reception and dispatch by transparently creating a system thread to handle incoming messages. Use this if you do not want to handle the threading yourself.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>If NULL is passed then an unused port will be chosen by the system, its number may be retrieved with <a class="el" href="lo__serverthread_8h.html#a22f4b18eeac41490647ab9fe2333f933" title="Return the port number that the server thread has bound to. ">lo_server_thread_get_port()</a> so it can be passed to clients. Otherwise a decimal port number, service name or UNIX domain socket path may be passed. </td></tr>
    <tr><td class="paramname">err_h</td><td>A function that will be called in the event of an error being raised. The function prototype is defined in <a class="el" href="lo__types_8h.html">lo_types.h</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aac49abadaaac33408eae4060bb44b9a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="lo__types_8h.html#a09996ffb6bde21b8fb6106897b88feae">lo_server_thread</a> lo_server_thread_new_from_url </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lo__types_8h.html#aa5d2e4aa0ff9d4459fcc76e7ed5839fc">lo_err_handler</a>&#160;</td>
          <td class="paramname"><em>err_h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new server thread, taking port and the optional multicast group IP from an URL string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">url</td><td>The URL to specify the server parameters. </td></tr>
    <tr><td class="paramname">err_h</td><td>An error callback function that will be called if there is an error in messge reception or server creation. Pass NULL if you do not want error handling. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new lo_server_thread instance. </dd></dl>

</div>
</div>
<a class="anchor" id="a0fa9fcae4eabe09847d46b134dc33aa4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="lo__types_8h.html#a09996ffb6bde21b8fb6106897b88feae">lo_server_thread</a> lo_server_thread_new_multicast </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lo__types_8h.html#aa5d2e4aa0ff9d4459fcc76e7ed5839fc">lo_err_handler</a>&#160;</td>
          <td class="paramname"><em>err_h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new server thread to handle incoming OSC messages, and join a UDP multicast group. </p>
<p>Server threads take care of the message reception and dispatch by transparently creating a system thread to handle incoming messages. Use this if you do not want to handle the threading yourself.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group</td><td>The multicast group to join. See documentation on IP multicast for the acceptable address range; e.g., <a href="http://tldp.org/HOWTO/Multicast-HOWTO-2.html">http://tldp.org/HOWTO/Multicast-HOWTO-2.html</a> </td></tr>
    <tr><td class="paramname">port</td><td>If NULL is passed then an unused port will be chosen by the system, its number may be retrieved with <a class="el" href="lo__serverthread_8h.html#a22f4b18eeac41490647ab9fe2333f933" title="Return the port number that the server thread has bound to. ">lo_server_thread_get_port()</a> so it can be passed to clients. Otherwise a decimal port number, service name or UNIX domain socket path may be passed. </td></tr>
    <tr><td class="paramname">err_h</td><td>A function that will be called in the event of an error being raised. The function prototype is defined in <a class="el" href="lo__types_8h.html">lo_types.h</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad6d57101bbdaa6571ed76373b2c3a50a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="lo__types_8h.html#a09996ffb6bde21b8fb6106897b88feae">lo_server_thread</a> lo_server_thread_new_multicast_iface </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>iface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lo__types_8h.html#aa5d2e4aa0ff9d4459fcc76e7ed5839fc">lo_err_handler</a>&#160;</td>
          <td class="paramname"><em>err_h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new server thread instance, and join a UDP multicast group, optionally specifying which network interface to use. Note that usually only one of iface or ip are specified. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group</td><td>The multicast group to join. See documentation on IP multicast for the acceptable address range; e.g., <a href="http://tldp.org/HOWTO/Multicast-HOWTO-2.html">http://tldp.org/HOWTO/Multicast-HOWTO-2.html</a> </td></tr>
    <tr><td class="paramname">port</td><td>If using UDP then NULL may be passed to find an unused port. Otherwise a decimal port number or service name or may be passed. If using UNIX domain sockets then a socket path should be passed here. </td></tr>
    <tr><td class="paramname">iface</td><td>A string specifying the name of a network interface to use, or zero if not specified. </td></tr>
    <tr><td class="paramname">ip</td><td>A string specifying the IP address of a network interface to use, or zero if not specified. </td></tr>
    <tr><td class="paramname">err_h</td><td>An error callback function that will be called if there is an error in messge reception or server creation. Pass NULL if you do not want error handling. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6713cedfb0b2c4f066ec8a19366bf095"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="lo__types_8h.html#a09996ffb6bde21b8fb6106897b88feae">lo_server_thread</a> lo_server_thread_new_with_proto </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>proto</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lo__types_8h.html#aa5d2e4aa0ff9d4459fcc76e7ed5839fc">lo_err_handler</a>&#160;</td>
          <td class="paramname"><em>err_h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new server thread to handle incoming OSC messages, specifying protocol. </p>
<p>Server threads take care of the message reception and dispatch by transparently creating a system thread to handle incoming messages. Use this if you do not want to handle the threading yourself.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>If NULL is passed then an unused port will be chosen by the system, its number may be retrieved with <a class="el" href="lo__serverthread_8h.html#a22f4b18eeac41490647ab9fe2333f933" title="Return the port number that the server thread has bound to. ">lo_server_thread_get_port()</a> so it can be passed to clients. Otherwise a decimal port number, service name or UNIX domain socket path may be passed. </td></tr>
    <tr><td class="paramname">proto</td><td>The protocol to use, should be one of LO_UDP, LO_TCP or LO_UNIX. </td></tr>
    <tr><td class="paramname">err_h</td><td>A function that will be called in the event of an error being raised. The function prototype is defined in <a class="el" href="lo__types_8h.html">lo_types.h</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6ba794aacbb04dada6939980ce71381a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lo_server_thread_pp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lo__types_8h.html#a09996ffb6bde21b8fb6106897b88feae">lo_server_thread</a>&#160;</td>
          <td class="paramname"><em>st</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pretty-print a lo_server_thread object. </p>

</div>
</div>
<a class="anchor" id="ab4d5248ecc0d55e46c0f025e727ceb52"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lo_server_thread_set_callbacks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lo__types_8h.html#a09996ffb6bde21b8fb6106897b88feae">lo_server_thread</a>&#160;</td>
          <td class="paramname"><em>st</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lo__types_8h.html#a7686daba989edab6324cb2957f9f1333">lo_server_thread_init_callback</a>&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lo__types_8h.html#a79a141110b391d4a8c62a3cd397de175">lo_server_thread_cleanup_callback</a>&#160;</td>
          <td class="paramname"><em>cleanup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set an init and/or a cleanup function to the specifed server thread. </p>
<p>To have any effect, it must be called before the server thread is started.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">st</td><td>The server thread to which the method is to be added. </td></tr>
    <tr><td class="paramname">init</td><td>The init function to be called just after thread start. May be NULL. </td></tr>
    <tr><td class="paramname">cleanup</td><td>The cleanup function to be called just before thread exit. May be NULL. </td></tr>
    <tr><td class="paramname">user_data</td><td>A value that will be passed to the callback functions. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4b284c1b96d0354c5de4ff7ba5a44fbc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lo_server_thread_start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lo__types_8h.html#a09996ffb6bde21b8fb6106897b88feae">lo_server_thread</a>&#160;</td>
          <td class="paramname"><em>st</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start the server thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">st</td><td>the server thread to start. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Less than 0 on failure, 0 on success. </dd></dl>

</div>
</div>
<a class="anchor" id="a06992ac46b04e58cb77d7c519a578f57"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lo_server_thread_stop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lo__types_8h.html#a09996ffb6bde21b8fb6106897b88feae">lo_server_thread</a>&#160;</td>
          <td class="paramname"><em>st</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stop the server thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">st</td><td>the server thread to start. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Less than 0 on failure, 0 on success. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
